Introduction<br/><br/>In this project, we have developed a Stock Analysis Application using React.js, designed to fetch, process, and visually display stock performance data for selected companies. The application allows users to view historical stock data for multiple companies, calculate important financial metrics (such as monthly returns and annual returns), and present the information in both tabular and chart formats. We used modern libraries and techniques such as react-chartjs-2 for interactive charts, Tailwind CSS for responsive styling, and the Alpha Vantage API for fetching real-time stock data.<br/>For the purpose of this project, three demo stocks (MSFT, TSCO.LON, and IBM) are used. This decision was made due to the limitations on non-demo stocks, which are restricted to a maximum of 25 API calls per day. By using demo stocks, the application can function without hitting those restrictions during testing and development<br/><br/>What We Did in This Project <br/>1. Component-based Architecture<br/>We built the application using React's component-based approach to create reusable and maintainable code. The key components developed include:<br/>StockTable Component: Displays historical stock data and calculated returns in a table format. <br/>StockChart Component: Renders an interactive line chart to show stock performance over time using ```react-chartjs-2```. <br/>StockDetail Component: Manages the app's state, handles data loading, and coordinates the table and chart components. <br/>2. Data Fetching and API Integration <br/>We used the Alpha Vantage API to fetch historical stock data. The ```fetchStockData``` and ```fetchFilteredData``` functions were created to handle the API requests, format the data, and filter it by date range (e.g., 2018–2023). <br/>Implemented caching to minimize repeated API calls and improve performance by storing previously fetched stock data. <br/>3. Stock Data Calculation <br/>We wrote utility functions to process the stock data into a format suitable for display in both tables and charts. <br/> This included: <br/>Monthly Returns Calculation: We calculated the percentage return for each month based on stock prices. <br/>Annual Returns Calculation: By using monthly returns, we computed the compounded annual returns to provide a summary of stock performance over each year. <br/>Average and Standard Deviation: Calculations for average monthly returns and standard deviation of returns were also implemented to provide further insights. <br/>4. Data Visualization <br/>Using react-chartjs-2, we visualized the stock performance over time in a line chart. Different companies are represented by different colors and shapes, and the chart includes custom plugins for additional visual tweaks like padding and point styles. <br/>The table was built using React, and it displays stock performance metrics in a user-friendly format with calculated values for each month and year. <br/>5. Responsive Design with Tailwind CSS <br/>The application is fully responsive, thanks to Tailwind CSS. It adapts seamlessly to different screen sizes, ensuring a consistent user experience on both desktop and mobile devices. <br/>6. User Interaction <br/>Users can select between multiple stock symbols (e.g., MSFT, TSCO-LON, IBM) to view detailed performance data. The data and charts dynamically update when the selected stock changes.<br/>We added error handling and loading states to ensure that the app provides feedback while fetching data or when an error occurs during API requests.<br/><br/><br/>Summary<br/>This project showcases the combination of React.js for front-end development, Chart.js (via ```react-chartjs-2```) for data visualization, Alpha Vantage API for stock data retrieval, and Tailwind CSS for responsive design. The application provides users with a way to analyze and compare historical stock performance with visual charts and tables, using modern web development techniques to ensure interactivity, performance, and ease of use. <br/><br/><br/><br/><br/><br/>Project Structure<br/>project is organized as follows: <br/>src/: Contains all React components, styles, and utility functions. <br/>components/: Contains individual component files for StockTable, StockChart, and StockDetail. <br/>App.js: The main application file that combines components. <br/><br/>Component Breakdown :<br/>1. StockTable Component```<br/>import "../App.css"; <br/>import { useState, useMemo } from 'react';<br/>import { useTable } from "react-table";<br/><br/>function StockTable(props) {<br/>  return <Table data={props.stockData} />;<br/>};<br/>```<br/><br/><br/><br/>```import "../App.css"```; <br/>Purpose: This line imports the CSS file App.css, which contains global styles for the application. <br/>Effect: It applies the CSS rules defined in ```App.css``` to all components in the application, including ```StockTable```. This ensures that any custom styles in that file are applied to the component. <br/>Note: The relative path ```(../)``` indicates that the CSS file is located one directory level above the current file. <br/>'<br/>```import { useState, useMemo } from 'react'```; <br/>Purpose: This line imports```useState``` and ```useMemo```, two hooks from the core React library that are necessary for handling state and optimizing performance in the component. <br/>```useState```: <br/>A hook that allows us to add state to my function component.<br/>we can use ```useState``` to track variables such as user interactions, component data, or other dynamic values. <br/>```useMemo```: <br/>A hook that memoizes values or computations, so they are only recalculated when necessary (i.e., when dependencies change). It is used to optimize performance, especially in expensive operations. <br/>In the ```StockTable``` component, ```useMemo``` is typically used to memoize the columns configuration or computed data for the table, ensuring that the table re-renders only when necessary, thus improving performance. <br/>```import { useTable } from "react-table"```; <br/>Purpose: This line imports the ```useTable``` hook from the ```react-table``` library, which is essential for creating tables with customizable columns and rows. <br/>```useTable```: <br/>It is a powerful hook that provides the logic needed to structure and render a table in React. <br/>It handles: <br/>Table headers and rows Sorting, filtering, pagination, etc. <br/>This hook gives us the tools to create tables in a declarative manner with control over each part of the table (rows, headers, cells). <br/>```function StockTable(props) {```<br/>Purpose: This is the declaration of the ```StockTable``` functional component. It accepts ```props``` as an argument, which is a standard way in React to pass data from a parent component to a child component. <br/>Props: The ```props``` object contains all the data passed to ```StockTable```, including the ```stockData``` that will be displayed in the table. <br/>In the context of this project: The parent component of ```StockTable``` will provide the stock market data through ```props.stockData```. <br/><br/><br/>```return <Table data={props.stockData} />```; <br/>Purpose: This line renders another component called ```Table``` and passes the stock data (```props.stockData```) as a prop to it. <br/>Table Component: The actual implementation of the ```table``` is abstracted to another component (```Table```). ```StockTable``` acts as a wrapper or high-level component responsible for passing the necessary data to the ```Table``` component. <br/>```data={props.stockData}```: The ```stockData``` prop is passed down from ```StockTable``` to ```Table```, where it will be used to populate the table rows. <br/><br/>```const Table = (props) => {  const columns = useMemo(() => [    { Header: "Year", accessor: "year" },    //... other columns<br/>  ], []);```<br/><br/>Table Function: Defines the main table logic. <br/>```Columns```: Uses ```useMemo``` for performance optimization, defining the structure of the table with headers and accessors corresponding to data fields. <br/><br/>```const { getTableProps, getTableBodyProps, headerGroups, rows, prepareRow } = useTable({ columns, data: props.data });```<br/>It is a key part of the ```react-table``` library, which is widely used in React applications for creating highly customizable tables. Here’s a detailed breakdown of what this line does: <br/><br/>```useTable``` Hook Overview <br/><br/>```useTable```: A hook that returns various properties and methods for table management, including props for the ```table``` and row preparation. <br/><br/>```columns```: This is the structure of  table. It defines the headers, the data fields they represent, and any other information (like sorting, filtering, etc.). <br/><br/>```data```: This is the array of data objects that will populate my table. Each object represents a row in my table, with keys corresponding to the column accessors. <br/><br/>Destructured Variables from ```useTable```<br/>When we call ```useTable```, it returns a number of functions and objects that help in rendering and managing the table. Here's what each of these destructured variables does: <br/><br/>```getTableProps```<br/>Purpose: This function returns props that are necessary to apply to the root ```<table>``` element for the table to function correctly. <br/><br/>Usage: It typically provides accessibility and other table-specific attributes, such as ```role="table"```. <br/><br/><br/>Example Usage:  <br/><br/>```<table {...getTableProps()}>  {/* Table headers and body go here */}</table>```<br/><br/><br/>```getTableBodyProps``` <br/>Purpose: Similar to ```getTableProps```, but specifically for the ```<tbody>``` element. It ensures that any attributes or event handlers required by the ```tbody``` are applied. <br/><br/>Example Usage:<br/><br/>```<<tbody {...getTableBodyProps()}>< {/* Rows go here */}</tbody>``````headerGroups``` <br/>Purpose: This array contains all the header groups that my table has. Each ```headerGroup``` includes information for rendering the header rows. <br/><br/>Structure: Each ```headerGroup``` contains an array of headers that can be mapped to create the ```<th> ```elements for each column. <br/><br/>Example Usage:<br/><br/>```<b{headerGroups.map(headerGroup => (  <tr {...headerGroup.getHeaderGroupProps()}>    {headerGroup.headers.map(column => (      <th {...column.getHeaderProps()}>        {column.render('Header')}<br/>      </th><br/>    ))}<br/>  </tr><br/>))}<br/><br/>```<br/><br/><br/>Here, each header group can be rendered in a ```<tr>``` tag with multiple ```<th>``` tags, one for each column in the header group. <br/><br/>```rows``` <br/>Purpose: This is an array containing all the data rows in my table. Each ```row``` object represents a single row of my table and includes the necessary information to render each cell. <br/><br/>Usage: The ```rows``` array can be mapped over to create the actual table rows (```<tr>``` elements) in my table body. <br/><br/>Example Usage:<br/><br/>```<br/>{rows.map(row => {<br/>  prepareRow(row);<br/>  return (<br/>    <tr {...row.getRowProps()}><br/>      {row.cells.map(cell => (<br/>        <td {...cell.getCellProps()}><br/>          {cell.render('Cell')}<br/>        </td><br/>      ))}<br/>    </tr><br/>  );<br/>})}<br/>```<br/>```prepareRow``` <br/>Purpose: This function is called for each row before rendering it. It applies necessary properties like ```onClick``` handlers, accessibility attributes, and styles to each row.<br/>Usage: It must be called for every row before it is rendered in the ```rows.map()``` loop. <br/><br/>Hover State Management with ```useState``` <br/><br/>```const [hoveredHeaderGroupIndex, setHoveredHeaderGroupIndex] = useState(null); <br/>const [hoveredRowIndex, setHoveredRowIndex] = useState(null); <br/>const [hoveredColumnIndex, setHoveredColumnIndex] = useState(null); <br/>```<br/><br/>Purpose: These three ```useState``` hooks are used to track which part of the table (header, row, or column) is being hovered over. <br/>```hoveredHeaderGroupIndex```: Tracks which column header is currently being hovered. <br/>```hoveredRowIndex```: Tracks which row is being hovered. <br/>```hoveredColumnIndex```: Tracks which column in the table body is being hovered. <br/>By tracking these states, we can dynamically apply styles (like highlighting the header, row, or column) when the user moves their mouse over specific areas of the table. <br/><br/> JSX Structure of the Table <br/><br/><br/>```<br/>return (<br/>  <div className="App relative"><br/>    <div className="container table-container"><br/>      <table {...getTableProps()} className="custom-table table fixed-table items-center w-full text-black"><br/>```<br/><br/><br/>Purpose: This block represents the layout and rendering logic for the table structure in JSX. <br/>```getTableProps()```: This method comes from the ```useTable``` hook from the ```react-table``` library. It provides all necessary props (like ```aria-*```, ```role```, ```style```, etc.) required to render a table that conforms to accessibility and table standards. <br/>CSS Classes: Custom Tailwind CSS classes (```custom-table```, ```fixed-table```, etc.) are applied for styling the table and controlling layout, width, text color, etc. <br/><br/><br/><br/>Table Header Rendering <br/><br/>```<br/><thead className="p-3 items-center w-full border-2 border-black rounded-lg head-layout"><br/>  {headerGroups.map((headerGroup, headerGroupIndex) => (<br/>    <tr {...headerGroup.getHeaderGroupProps()} className="p-3 items-center w-1/12 cell-margin rounded-md border-b"><br/>      {headerGroup.headers.map((column, index) => (<br/>        <th<br/>          onMouseEnter={() => setHoveredHeaderGroupIndex(index)}<br/>          onMouseLeave={() => setHoveredHeaderGroupIndex(null)}<br/>          {...column.getHeaderProps()}<br/>          className={`p-3 text-center text-sm table-container w-1/12 column-${index} <br/>            ${hoveredColumnIndex !== 0 && hoveredColumnIndex === index ? 'hovered' : ''}<br/>            ${hoveredHeaderGroupIndex !== 0 && hoveredHeaderGroupIndex === index ? 'hovered' : ''}<br/>            ${index === 0 ? 'first-header-th' : ''}<br/>            ${index === headerGroup.headers.length - 1 ? 'last-header-th' : ''}`}<br/>        ><br/>          {column.render("Header")}<br/>        </th><br/>      ))}<br/>    </tr><br/>  ))}<br/></thead><br/>```<br/><br/>Purpose: This block handles the rendering of the table header. <br/><br/>```headerGroups```: Comes from ```useTable```, it contains groups of headers (useful in cases where there are multi-level headers). <br/><br/><br/>Hover Events: <br/>When the user hovers over a header (```onMouseEnter```), the corresponding ```index``` is set to ```hoveredHeaderGroupIndex```. <br/>When the user stops hovering (```onMouseLeave```), the ```hoveredHeaderGroupIndex``` is reset to ```null```. <br/>This allows for dynamic highlighting of headers as the user interacts with them. <br/><br/><br/>Dynamic Classes: <br/>The dynamic classes (e.g., ```${hoveredColumnIndex === index ? 'hovered' : ''}```) apply specific styles when a header or column is hovered. <br/>Example: The ```hovered``` class is conditionally applied when the current column is being hovered. <br/><br/><br/> Table Body Rendering <br/><br/> ```<br/> <tbody {...getTableBodyProps()} className="p-3 cell-margin bg-white"><br/>  {rows.map((row, rowIndex) => {<br/>    prepareRow(row);<br/>    return (<br/>      <tr<br/>        {...row.getRowProps()}<br/>        className={`${hoveredRowIndex === rowIndex ? 'hovered-row' : ''}`}<br/>        onMouseEnter={() => setHoveredRowIndex(rowIndex)}<br/>        onMouseLeave={() => setHoveredRowIndex(null)}<br/>      ><br/>        {row.cells.map((cell, columnIndex) => (<br/>          <td<br/>            {...cell.getCellProps()}<br/>            className="w-1/12 p-[4px]"<br/>            onMouseEnter={() => setHoveredColumnIndex(columnIndex)}<br/>            onMouseLeave={() => setHoveredColumnIndex(null)}<br/>          ><br/>            <div className={`${getCellColorClass(cell.value, cell)} padding-cell rounded-lg <br/>              ${columnIndex === 0 && hoveredRowIndex === rowIndex ? "year-hover" : ''}<br/>              ${hoveredColumnIndex == 0 && hoveredRowIndex !== rowIndex ? 'hoveredd' : ''}<br/>              ${hoveredHeaderGroupIndex !== null && hoveredHeaderGroupIndex !== columnIndex ? 'hoveredd' : ''}`}<br/>            ><br/>              {cell.column.Header !== "Year" ? `%${cell.value}` : cell.render("Cell")}<br/>            </div><br/>          </td><br/>        ))}<br/>      </tr><br/>    );<br/>  })}<br/></tbody><br/>```<br/><br/><br/>Purpose: This block renders the body of the table. <br/><br/>```rows```: Represents the rows of data, which are dynamically generated based on the ```props.data``` passed to the component. <br/>```prepareRow(row)```: A function from ```useTable``` that prepares the row data and ensures that proper props are added for rendering. <br/><br/>Dynamic Hovering: <br/><br/>Just like the table headers, the rows and cells are also interactive. <br/>When the user hovers over a row (```onMouseEnter```), the ```hoveredRowIndex``` state is set, which triggers a CSS class (```hovered-row```) to style the row. <br/>Similarly, hovering over columns (```hoveredColumnIndex```) allows individual columns to be highlighted. <br/>```getCellColorClass```: This function is applied to each cell to determine its color class based on the cell's value. It ensures that cells are color-coded based on their data. <br/><br/>Table Footer with Averages and Standard Deviation <br/><br/><br/>```<br/><tfoot className="mt-4 cell-margin p-3"><br/>  <tr><br/>    {columns.map((column) => {<br/>      const averageRow = props.data.find(item => item.year === "average");<br/>      const averageValue = averageRow ? averageRow[column.accessor] : "";<br/>      return (<br/>        <td key={column.accessor} className="padding-cell p-[4px] rounded-lg"><br/>          <div className={`${getCellColorClass(averageValue, { column })} padding-cell rounded-lg`}><br/>            {averageValue !== "average" ? `%${averageValue}` : "average"}<br/>          </div><br/>        </td><br/>      );<br/>    })}<br/>  </tr><br/>  <tr><br/>    {columns.map((column) => {<br/>      const standardDeviationRow = props.data.find(item => item.year === "standard deviation");<br/>      const standardDeviationValue = standardDeviationRow ? standardDeviationRow[column.accessor] : "";<br/>      return (<br/>        <td key={column.accessor}><br/>          <div className={`rounded-lg p-[4px] ${standardDeviationValue !== "standard deviation" ? 'hovereddd' : ''}`}><br/>            {standardDeviationValue !== "standard deviation" ? `%${standardDeviationValue}` : "standard deviation"}<br/>          </div><br/>        </td><br/>      );<br/>    })}<br/>  </tr><br/></tfoot><br/>```<br/><br/><br/>Purpose: This block renders the footer, where calculated data such as "average" and "standard deviation" are displayed. <br/>Average and Standard Deviation: These values are derived from ```props.data```. The ```averageRow``` and ```standardDeviationRow``` are found by looking for rows where ```year``` equals "average" or "standard deviation". <br/>Dynamic Rendering: If a value exists, it is displayed with the format ```"%${value}"```, otherwise it shows either "average" or "standard deviation". <br/>CSS Classes: Hover effects (```hovereddd```) are applied similarly to the body and header, allowing for interactive styling. <br/><br/><br/><br/><br/>Explanation of Each Code Block <br/>Table Setup: <br/>The table is structured using ```getTableProps()``` to ensure that all table-wide attributes are applied. <br/>Headers: <br/>For each header group, the ```getHeaderGroupProps()``` is applied to the ```<tr>```. Inside each ```<tr>```, we iterate over the headers and use ```getHeaderProps()``` to ensure each ```<th>``` has the right properties. The actual column name is rendered using ```column.render('Header')```. <br/>Rows and Cells: <br/>For each row in the ```rows``` array, we first call ```prepareRow(row)``` to attach necessary props and behaviors. <br/>Each row renders its cells inside ```<td>``` tags, where we apply ```getCellProps()``` to ensure each cell has the right attributes, and ```cell.render('Cell')``` is used to render the cell’s content. <br/><br/>Summary <br/>This code implements a dynamic, responsive table with the ability to track and visually highlight hovered rows, columns, and headers. <br/>The table is built using ```react-table```, with custom styles applied through Tailwind CSS and additional logic for hover interactions. <br/>Hover states for headers, rows, and columns are managed using ```useState```, and styling is dynamically applied based on these states. <br/>Footer rows are added to display averages and standard deviations, calculated from the table data, and hover effects are also applied here. <br/><br/><br/><br/>StockChart Component <br/>The ```StockChart``` component in my project is designed to display a stock chart using the ```react-chartjs-2``` library, which leverages ```Chart.js``` for creating a variety of charts in a React application. This specific implementation focuses on rendering a line chart for stock data, showing stock symbols and their corresponding annual returns. Below is a detailed breakdown of the code and its functionalities: <br/><br/> Import Statements <br/><br/> ```<br/> import { Line } from "react-chartjs-2";<br/>import { Chart, registerables } from 'chart.js';<br/>```<br/><br/><br/>Purpose: These import statements bring in the necessary libraries and components to create the chart. <br/>```Line```: This is the React wrapper for the ```Line``` chart from Chart.js, used to create the line graph. <br/>```Chart``` and ```registerables```: These are core components of Chart.js. ```registerables``` includes essential elements like scales, legends, and tooltips that need to be registered with Chart.js. <br/><br/><br/>Registering Chart.js Components <br/><br/>```<br/>Chart.register(...registerables);<br/><br/>```<br/><br/>Purpose: This line registers all the necessary components from ```Chart.js``` to ensure that the line chart can be rendered correctly with features like axes, legends, and tooltips.<br/>Without this registration, Chart.js would not have access to the necessary elements to create and display the chart. <br/><br/><br/>Custom Legend Padding Plugin <br/><br/>```<br/>const legendPaddingPlugin = {<br/>  id: 'legendPadding',<br/>  beforeInit(chart) {<br/>    const originalFit = chart.legend.fit;<br/>    chart.legend.fit = function () {<br/>      originalFit.call(chart.legend);<br/>      this.height += 50; // Adjust this value for more or less space<br/>    };<br/>  }<br/>};<br/><br/><br/>```<br/><br/>Purpose: This custom plugin adjusts the padding around the chart's legend, providing extra space between the legend and the chart. <br/>```beforeInit(chart)```: Hooks into the chart initialization process. <br/>Custom ```fit()```: Overrides the default fitting function for the legend, adding 50 pixels of additional padding to improve the visual layout. <br/><br/><br/>Defining Line Styles with pointStyles <br/><br/>```<br/>const pointStyles = ['circle', 'rect', 'triangle', 'cross', 'line'];<br/><br/>```<br/><br/>Purpose: This array defines different shapes (```circle```, ```rect```, etc.) for the points on each line of the chart. Each dataset (stock) can have a different point shape to distinguish it visually on the chart. <br/><br/><br/>Generating the Chart's Datasets <br/><br/>```<br/>const datasets = props.stockDataList.map((item, index) => {<br/>  const isTSCO = item.symbol === "TSCO-LON";<br/>  const annualReturn = item.annualReturns[0] ? item.annualReturns[0].annualReturn : 0;<br/><br/>  const dataEntries = Object.entries(item.calcData[0]).slice(1);<br/>  const lastIndex = dataEntries.length - 1;<br/><br/>  return {<br/>    label: `${item.symbol} : ${annualReturn}%`,<br/>    data: dataEntries,<br/>    fill: false,<br/>    borderColor: getColorByIndex(index),<br/>    tension: 0.1,<br/>    pointRadius: dataEntries.map((_, idx) => (idx === lastIndex ? 5 : 0)),<br/>    pointStyle: isTSCO && index === datasets.length - 1 ? 'rect' : pointStyles[index % pointStyles.length],<br/>    backgroundColor: getColorByIndex(index),<br/>    pointHoverRadius: 5,<br/>    showLine: true,<br/>  };<br/>});<br/><br/>```<br/><br/>Purpose: This block generates the datasets for the chart based on the stock data passed in via ```props```. <br/>```item.symbol```: The stock symbol (e.g., "TSCO-LON") is displayed in the legend. <br/>```item.annualReturns[0]```: The annual return percentage is displayed next to the stock symbol. <br/>```dataEntries```: Represents the actual data points for the stock's performance. These are sliced to exclude the first entry (typically a label or a year). <br/>```borderColor```: The color of the line for each stock, determined by the ```getColorByIndex``` function. <br/>```pointRadius```: Shows the last point on the line with a larger radius (5), while all other points are hidden (```0```). <br/>```pointStyle```: Uses custom point shapes, with special handling for the "TSCO-LON" stock. <br/>```showLine```: Ensures that lines are drawn even if there are only a few data points. <br/><br/><br/><br/>Rendering the Line Chart <br/><br/>```<br/><Line<br/>  data={{ datasets: datasets }}<br/>  options={{<br/>    parsing: { xAxisKey: '[0]', yAxisKey: '[1]' },<br/>    scales: {<br/>      x: { grid: { display: false } },<br/>      y: {<br/>        grid: { display: true, drawBorder: false },<br/>        ticks: { display: true, callback: (value) => `%${value}`, padding: 10 },<br/>        title: { display: true, text: 'Return', padding: { top: 10 } },<br/>        border: { display: false }<br/>      }<br/>    },<br/>    elements: { line: { borderWidth: 2 } },<br/>    plugins: {<br/>      legend: { position: 'bottom', padding: 50 }<br/>    },<br/>    hover: {<br/>      mode: 'index',<br/>      intersect: false<br/>    }<br/>  }}<br/>  plugins={[legendPaddingPlugin]}<br/>/><br/><br/>```<br/><br/>Purpose: This block renders the actual line chart with all the configurations. <br/>Data: The ```datasets``` generated in the previous step are passed into the ```Line``` component. <br/>Options:<br/>```scales```: Configures the x and y axes: <br/>The x-axis does not display grid lines (```display: false```). <br/>The y-axis displays grid lines but without a border (```drawBorder: false```). <br/>Custom Tick Labels: Y-axis values are shown as percentages (```callback: (value) =>``` %${value}). <br/>```legend```: Positioned at the bottom with additional padding. <br/>```hover```: Configures hovering behavior so that hovering over a point highlights all data points for that specific index (x-axis). <br/>Custom Plugin: The ```legendPaddingPlugin``` is applied to add padding between the legend and the chart. <br/><br/><br/><br/>Color Utility Function <br/><br/>```<br/>const getColorByIndex = (index) => {<br/>  switch (index) {<br/>    case 0: return '#cd6a71';<br/>    case 1: return '#e09b47';<br/>    case 2: return '#05e26b';<br/>    case 3: return '#5c33fe';<br/>    case 4: return '#36cd84';<br/>    default: return '#000'; // Fallback color<br/>  }<br/>};<br/><br/>```<br/><br/>Purpose: This function assigns a unique color to each dataset based on its index. It provides visual distinction between multiple lines on the chart. <br/>```switch (index)```: A different color is returned for each dataset (line). If there are more than 5 datasets, it falls back to black (```#000```). <br/><br/><br/><br/>Summary <br/>The ```StockChart``` component is a well-structured React component that dynamically creates and renders a line chart based on stock data passed through ```props```. <br/>The use of ```react-chartjs-2``` and ```Chart.js``` allows for powerful, customizable charting with features like interactive hover states, custom point styles, and dynamic legends. <br/>The custom ```legendPaddingPlugin``` is used to control the padding between the chart and the legend, enhancing the visual layout. <br/>Hover states are configured to highlight corresponding data points across the chart, and the y-axis is formatted to display values as percentages. <br/>The datasets are built dynamically, with each ```dataset``` representing a stock's performance, including special handling for the "TSCO-LON" stock. <br/><br/><br/>StockDetail Component <br/><br/>The ```StockDetail``` component is the main container that coordinates fetching stock data, performing calculations, and rendering both the stock table and chart components. The following sections break down each part of the code and explain its purpose and functionality. <br/><br/>Import Statements <br/><br/>```<br/>import "../App.css";<br/>import { useState, useEffect, useMemo } from 'react';<br/>import StockChart from './StockChart';<br/>import StockTable from './StockTable';<br/>import { fetchFilteredData } from '../repo/DataRepo';<br/>import { calculateStockDataForTable } from '../utils/StockCalc';<br/><br/>```<br/><br/>Purpose: These import statements pull in the required modules and files. <br/>```App.css```: CSS file for styling the component. <br/>```useState, useEffect, useMemo```: React hooks used to manage state, handle side effects, and optimize calculations. <br/>```StockChart``` & ```StockTable```: Child components that display the stock data in different formats (chart and table). <br/>```fetchFilteredData```: A utility function to fetch stock data for a specific time range. <br/>```calculateStockDataForTable```: A utility function to process and format the stock data for display in the table. <br/><br/><br/><br/>State Management <br/><br/>```<br/><br/>const allSymbols = ["MSFT", "TSCO.LON", "IBM"];<br/>const [selectedSymbol, setSelectedSymbol] = useState(allSymbols[0]);<br/>const [stockData, setStockData] = useState([]);<br/>const [loading, setLoading] = useState(true);<br/>const [error, setError] = useState(null);<br/><br/>```<br/><br/>Purpose: Manages component state. <br/>```allSymbols```: An array of stock symbols for Microsoft (```MSFT```), Tesco (```TSCO.LON```), and IBM (```IBM```). These are the stocks that will be displayed. <br/>```selectedSymbol```: Tracks the currently selected stock symbol for display. Initially set to the first symbol in ```allSymbols``` (Microsoft). <br/>```stockData```: Holds the stock data fetched for all the symbols. <br/>```loading```: Tracks whether data is being fetched (```true```) or has finished loading (```false```). <br/>```error```: Holds any errors encountered during data fetching. <br/><br/><br/><br/>Fetching Stock Data <br/><br/>```<br/>const getDataFromRepo = async (symbol) => {<br/>  return { symbol: symbol, list: await fetchFilteredData(symbol, 2018, 2023) };<br/>};<br/><br/>const loadData = async () => {<br/>  setLoading(true);<br/>  const allStocksData = await Promise.all(allSymbols.map((symbol) => getDataFromRepo(symbol)));<br/>  setLoading(false);<br/>  if (allStocksData.every((item) => item.list !== null)) {<br/>    setStockData(allStocksData);<br/>  } else {<br/>    setError('Failed to fetch stock data');<br/>  }<br/>};<br/><br/>```<br/><br/><br/><br/>```getDataFromRepo(symbol)```: Fetches stock data for a specific symbol from the ```DataRepo``` module for the years 2018–2023. <br/><br/>Returns an object containing the symbol and its corresponding stock data. <br/>```loadData()```:Initiates the data fetching process by setting ```loading``` to ```true```.<br/>Fetches stock data for all symbols using ```Promise.all()```, which allows multiple async operations to run concurrently. <br/>If data fetching is successful (```allStocksData.every((item) => item.list !== null)```), the state variable ```stockData``` is updated with the fetched data. <br/>If there’s an error, it sets the ```error``` state with a failure message. <br/><br/><br/> useEffect Hook <br/><br/> ```<br/> useEffect(() => {<br/>  loadData();<br/>}, []);<br/><br/>```<br/><br/>Purpose: The ```useEffect``` hook ensures that ````loadData()```is called once when the component first mounts. This is how the stock data is initially fetched when the user opens the application. <br/><br/><br/><br/>Handling Loading and Error States <br/><br/>```<br/>if (loading) return <p>Loading...</p>;<br/>if (error) return <><br/>  <p>{error}</p><br/>  <button onClick={() => loadData()}>Reload</button><br/></>;<br/><br/>```<br/><br/>Loading State: If the ```loading``` state is ```true```, a loading message is displayed.<br/>Error State: If there’s an error (```error !== null```), it displays the error message and provides a button to retry loading the data by calling ```loadData()``` again. <br/><br/><br/><br/>Calculating Data for Display <br/><br/>```<br/>const calculatedDataList = stockData.map((data) => {<br/>  const dataForTable = calculateStockDataForTable(data.list);<br/>  return { symbol: data.symbol, calcData: dataForTable.returns, annualReturns: dataForTable.annualReturns };<br/>});<br/><br/>```<br/>Purpose: This code processes the fetched stock data to calculate the necessary data for both the table and the chart. <br/>```calculateStockDataForTable(data.list)```: This function processes the stock data to extract the necessary values for displaying returns and annual returns. <br/>The result is an array of objects where each object contains: <br/>```symbol```: The stock symbol. <br/>```calcData```: Calculated return data to be displayed in the table. <br/>```annualReturns```: Annual return percentages for the stock. <br/><br/><br/><br/>Rendering the Component <br/><br/>```<br/>return <div className="container mx-auto "><br/>  <div className="flex-col lg:flex-row space-y-4 lg:space-y-0 lg:space-x-4"><br/>    {allSymbols.map((item) => {<br/>      return <button onClick={() => setSelectedSymbol(item)} className="open && 'bg-gray-100'..."><br/>        {item}<br/>      </button>;<br/>    })}<br/>    <div className="space-y-0.5"><br/>      <div className="flex-1"><br/>        <StockTable stockData={calculatedDataList.find((item) => item.symbol === selectedSymbol).calcData} /><br/>      </div><br/>      <div><br/>        <StockChart stockDataList={calculatedDataList} className="flex-1" /><br/>      </div><br/>    </div><br/>  </div><br/></div>;<br/><br/>```<br/><br/>Rendering the Buttons: <br/><br/>```allSymbols.map((item) => <button ...>{item}</button>)```: This loop creates a button for each stock symbol. When clicked, it updates the ```selectedSymbol``` state to display data for the clicked stock. <br/><br/>Rendering the Stock Table: <br/><br/>```StockTable stockData={calculatedDataList.find((item) => item.symbol === selectedSymbol).calcData}```: The ```StockTable``` component is rendered, passing the calculated table data for the currently selected stock. <br/><br/><br/>Rendering the Stock Chart: <br/><br/>```StockChart stockDataList={calculatedDataList}```: The ```StockChart``` component is rendered, passing the full list of calculated data for all stocks. <br/><br/><br/><br/>Summary <br/><br/>The ```StockDetail``` component orchestrates the following: <br/><br/>Fetching stock data for predefined symbols (```MSFT```, ```TSCO.LON```, and ```IBM```) from a remote source using the ```fetchFilteredData``` function. <br/>Handling loading and error states, ensuring that the UI is responsive to the status of data fetching. <br/>Processing the stock data into a format suitable for display in both a table and a chart using the utility function ```calculateStockDataForTable```. <br/>Rendering a dynamic user interface with buttons to switch between stocks, a table to display detailed stock data, and a chart to visualize the stock performance. <br/><br/>The component makes use of React hooks (```useState```, ```useEffect```), async functions for data fetching, and conditional rendering to handle different states (loading, error, or displaying data). <br/><br/><br/><br/><br/>DataRepo  <br/>Stock Data Fetching and Filtering Functions <br/><br/>This report covers the implementation of two JavaScript functions, ```fetchStockData``` and ```fetchFilteredData```, which are used to fetch stock market data from the Alpha Vantage API and filter it based on a specific time range. The functions also implement basic caching to avoid redundant API calls for the same data. <br/><br/><br/> Alpha Vantage API URL Construction <br/><br/> ```<br/> const stockUrl = (symbol) => `https://www.alphavantage.co/query?function=TIME_SERIES_MONTHLY_ADJUSTED&symbol=${symbol}&apikey=demo`;<br/><br/>```<br/>Purpose: The ```stockUrl``` function dynamically constructs the URL to access the Alpha Vantage API, specifically the TIME_SERIES_MONTHLY_ADJUSTED function, which provides historical stock prices on a monthly basis. <br/>```symbol```: The stock ticker symbol passed to the function, e.g., "MSFT" for Microsoft.<br/>```apikey=demo```: The API key required to access Alpha Vantage, though this uses a demo key. <br/><br/>Caching Mechanism <br/><br/>```<br/>const cachedData = {};<br/><br/>```<br/><br/>Purpose: This object acts as a simple in-memory cache to store previously fetched data. It helps avoid making repeated API calls for the same stock symbol and improves the efficiency of the function. <br/><br/>Why Caching Matters: <br/>API rate limits: Alpha Vantage, like many APIs, has a rate limit for how frequently we can make requests, especially with a demo key.<br/>Performance: Fetching stock data from an external API can be slow, so caching ensures that data for previously requested stocks is instantly available without waiting for the response. <br/><br/><br/>Fetching Stock Data <br/>```<br/>const fetchStockData = async (symbol) => {<br/>  try {<br/>    if (cachedData[symbol]) {<br/>      return cachedData[symbol];<br/>    }<br/>    const response = await fetch(stockUrl(symbol));<br/>    const data = await response.json();<br/>    if (!data["Monthly Adjusted Time Series"]) { <br/>      throw "data format error";<br/>    }<br/>    cachedData[symbol] = data;<br/>    return data;<br/>  } catch (err) {<br/>    console.log(err);<br/>  }<br/>  return null;<br/>};<br/><br/>```<br/><br/>Explanation: <br/>Input: Takes a stock ticker symbol (e.g., "AAPL" for Apple) as an argument. <br/>Caching Check: <br/>If the requested data for the stock symbol already exists in ```cachedData```, the function immediately returns that cached data. <br/>This reduces redundant API calls and ensures faster responses on subsequent requests for the same stock. <br/>Fetching Data: <br/>If the data is not cached, the function constructs the API URL using ```stockUrl(symbol)``` and makes an HTTP request using the ```fetch``` API. <br/>The response is parsed as JSON (```response.json()```), and the function checks if the data contains the "Monthly Adjusted Time Series" key, which holds the stock price data. <br/>Error Handling: <br/>If the data does not contain the expected structure, the function throws an error: ```"data format error"```. <br/>All errors, including potential network issues, are caught in the ```catch``` block, and the error is logged to the console. <br/>Return Value: <br/>On success, the fetched stock data is stored in the cache (```cachedData[symbol]```) and returned. <br/>If an error occurs or if the data is invalid, the function returns ```null```. <br/><br/>Summary: <br/>Caching improves performance and API usage efficiency. <br/>Error Handling prevents the application from breaking due to unexpected issues, such as network failures or incorrect data formats. <br/><br/><br/><br/>Filtering Stock Data by Year <br/><br/>```<br/>const fetchFilteredData = async (symbol, startYear, endYear) => {<br/>  try {<br/>    const data = await fetchStockData(symbol);<br/>    const dataListed = Object.entries(data["Monthly Adjusted Time Series"]);<br/>    return dataListed.filter((item) => {<br/>      const year = new Date(item[0]).getFullYear();<br/>      return year >= startYear && year <= endYear;<br/>    });<br/>  } catch (err) {<br/>    console.log(err);<br/>  }<br/>  return null;<br/>};<br/><br/>```<br/><br/><br/>Explanation: <br/>Input: Takes three arguments: <br/>```symbol```: The stock ticker symbol for which data is being requested. <br/>```startYear```: The start of the date range for filtering. <br/>```endYear```: The end of the date range for filtering. <br/>Fetching Data: <br/>Calls ```fetchStockData(symbol)``` to get the stock data for the specified symbol, which may come from the cache or the API. <br/>Converts the "Monthly Adjusted Time Series" data into an array using ```Object.entries()```.  This transforms the data into an array of key-value pairs where: <br/>The key is the date (e.g., "2023-09-30"). <br/>The value is the stock data for that month. <br/>Filtering Data by Year: <br/>```filter()```: Iterates over the data and filters it based on the year. <br/>```new Date(item[0]).getFullYear()```: Extracts the year from the date string (```item[0]```). <br/>The function checks whether the year is between the specified ```startYear``` and ```endYear```. <br/>Error Handling: <br/>As in ```fetchStockData```, any errors during data fetching or filtering are caught and logged to the console. <br/>If an error occurs, the function returns ```null```. <br/><br/>Summary: <br/>The ```fetchFilteredData``` function provides a convenient way to request stock data for a specific time range, ensuring that only relevant data is returned. <br/>It combines data fetching, caching, and filtering into a single step, making it easier to work with stock data in different parts of an application. <br/><br/><br/>Exporting the Functions <br/><br/>```<br/>export { fetchStockData, fetchFilteredData };<br/><br/>```<br/>Purpose: Both ```fetchStockData``` and ```fetchFilteredData``` are exported so that they can be used in other parts of the application. This modular structure allows developers to fetch stock data in different contexts, whether they need the full dataset or just a filtered subset. <br/><br/><br/><br/>Overall Functionality <br/>API Integration: <br/>Both functions integrate with the Alpha Vantage API to fetch stock market data, using a demo API key. <br/>Data Caching: <br/>Caching is implemented to minimize unnecessary API calls, improving the efficiency and speed of the application. <br/>Error Handling: <br/>Both functions include basic error handling mechanisms to log and handle errors gracefully without breaking the application. <br/>Data Filtering: <br/>The ```fetchFilteredData``` function allows filtering of stock data by a specific year range, ensuring only the relevant data is processed. <br/>Reusability: <br/>These functions are modular and reusable, making them flexible for different scenarios in stock data analysis applications. They can be used for generating stock performance reports, visualizations, or comparisons. <br/><br/><br/><br/>StockCalc <br/><br/>```calculateStockDataForTable``` Function <br/><br/>Purpose of the Function <br/>The ```calculateStockDataForTable``` function is designed to process stock data and compute various metrics that can be displayed in a table, such as: <br/>Monthly Returns: Calculates percentage returns for each month. <br/>Averages: Computes the average return for each month across the years. <br/>Standard Deviation: Calculates the standard deviation of monthly returns across the years. <br/>Annual Returns: Computes the overall annual return for each year based on the monthly returns. <br/>The processed data is then structured in a format suitable for display in a stock table. <br/><br/><br/><br/> Breakdown of the Process <br/> Initializing the Returns Array <br/><br/>```<br/>let returns = [];<br/><br/>```<br/><br/>Purpose: This array will hold the monthly returns for each year. Each entry in the array represents a year and its corresponding monthly returns. <br/><br/> Iterating Over the Stock Data <br/><br/> ```<br/> for (let i = 0; i < data.length; i++) {<br/>  const year = new Date(data[i][0]).getFullYear();<br/>  const month = new Date(data[i][0]).toLocaleString('default', { month: 'long' });<br/>  if (!returns.some((item) => item.year === year)) {<br/>    returns.push({ year: year });<br/>  }<br/><br/>```<br/><br/><br/>Explanation: <br/>The loop iterates through the stock data, which is a list of key-value pairs where each key is a date and the value is the stock information for that month. <br/>The function extracts the year and month from the data. <br/>It checks if the ```returns``` array already contains data for the current year. If not, it adds a new object representing that year. <br/><br/><br/>Calculating Monthly Returns <br/><br/>```<br/>const returnPercent = ((Number(previousMonth["5. adjusted close"]) - Number(currentMonth["5. adjusted close"])) / Number(currentMonth["5. adjusted close"])) * 100;<br/><br/>```<br/>Explanation: <br/>The percentage return for each month is calculated as: <br/><br/>Return = $\frac{(Previous Month’s Close − Current Month’s Close)}{Current Month’s Close} *100$​ <br/><br/><br/>The result is stored as the percentage ```return``` for the specific month and year in the returns array. <br/><br/><br/>Storing the Last Month's Return <br/><br/>```<br/>if (i + 1 >= data.length) {<br/>  const returnPercent = ((Number(currentMonth["5. adjusted close"]) - Number(currentMonth["1. open"])) / Number(currentMonth["1. open"])) * 100;<br/>  returns.find((item) => item.year === year)[month] = returnPercent.toFixed(2);<br/>}<br/>```<br/><br/>Explanation: <br/>When the loop reaches the last month, the function computes the return as the percentage change between the opening price and the adjusted closing price for that month. <br/><br/><br/>Calculating Averages for Each Month <br/><br/>```<br/>Calculating Averages for Each Month<br/><br/>```<br/><br/><br/>Purpose: This block computes the average monthly return across all years for each month. <br/>Explanation: <br/>For each month, the function adds up the returns across all years. <br/>After summing the returns, it divides by the number of years to get the average. <br/>The result is formatted to two decimal places. <br/><br/><br/><br/>Calculating Standard Deviation for Each Month <br/><br/>```<br/>const sd = { year: "standard deviation" };<br/>returns.forEach((item) => {<br/>  for (const i in item) {<br/>    if (i !== "year") {<br/>      sd[i] = (sd[i] || 0) + Math.pow(Number(item[i]) - av[i], 2);<br/>    }<br/>  }<br/>});<br/>for (const m in sd) {<br/>  if (m !== "year") {<br/>    sd[m] = Math.sqrt(sd[m] / (returns.length - 1)).toFixed(2);<br/>  }<br/>}<br/><br/>```<br/><br/>Purpose: This block computes the standard deviation of monthly returns across the years. <br/>Explanation: <br/>The standard deviation is calculated by finding the squared difference between each monthly return and the average monthly return, then taking the square root of the average of these squared differences. <br/><br/><br/> Calculating Annual Returns <br/><br/> ```<br/> const annualReturns = returns.map((item) => {<br/>  const months = Object.keys(item).filter((key) => key !== 'year');<br/>  const annualReturn = months.reduce((acc, month) => {<br/>    const monthValue = parseFloat(item[month]);<br/>    return acc * (1 + monthValue / 100);<br/>  }, 1) - 1;<br/>  return {<br/>    year: item.year,<br/>    annualReturn: (annualReturn * 100).toFixed(2)<br/>  };<br/>});<br/><br/>```<br/><br/>Purpose: This block calculates the overall annual return for each year by compounding the monthly returns. <br/>Explanation: <br/>The formula used to calculate the annual return is: <br/><br/>AnnualReturn = $ \prod_{i=1}^{12} (  1 + \frac{{Monthly Return}_i}{100} )$ - 1 <br/><br/><br/><br/>This compound interest-like calculation gives the total annual return based on the monthly percentage changes. <br/>The result is formatted as a percentage and stored in the ```annualReturns``` array. <br/><br/><br/>Final Data Structure <br/><br/>```<br/>returns.push(av);<br/>returns.push(sd);<br/>return { returns: returns, annualReturns: annualReturns };<br/><br/>```<br/><br/>Purpose: After calculating the monthly returns, averages, standard deviations, and annual returns, the function returns an object containing: <br/>```returns```: An array of yearly data with monthly returns, averages, and standard deviations.<br/>```annualReturns```: An array of annual returns for each year. <br/><br/><br/> Summary of Key Outputs <br/>Monthly Returns: The function calculates percentage returns for each month over multiple years.<br/>Averages: It computes the average monthly return for each month across all years.<br/>Standard Deviation: It calculates the standard deviation of the monthly returns for each month.<br/>Annual Returns: It computes the overall return for each year by compounding the monthly returns.